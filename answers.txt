-------------------------------------------------------------------------------
UCLA CS 111 Minilab 1. "WeensyOS"
Professor Peter Reiher
Winter 2014

FILE:	answers.txt

AUTHOR(s):
Alan Kha        904030522	akhahaha@gmail.com

-------------------------------------------------------------------------------

Exercise 1:
No. Scheduling another process may overwrite the eax register, which is 
required to return the correct pid value.

Exercise 2:
static pid_t o_fork(process_t *parent)
{	
	pid_t pid = 1;
	process_t* proc;
	do
	{
		proc = &proc_array[pid];
		
		if (proc->p_state == P_EMPTY)
		{
			proc->p_registers = parent->p_registers;
			copy_stack(proc, parent);
			proc->p_state = P_RUNNABLE;
			proc->p_registers.reg_eax = 0; // returns 0 to child
			return pid;
		}
		
		pid++;
	} while (pid <= NPROCS); // should be <= since we don't use proc_array[0]

	return -1;
}

static void
copy_stack(process_t *dest, process_t *src)
{	
	// get pids for source and destination
	pid_t src_pid = src->p_pid;
	pid_t dest_pid = dest->p_pid;
	
	uint32_t src_stack_top = PROC1_STACK_ADDR + (src_pid)*PROC_STACK_SIZE;
	uint32_t src_stack_bottom = src->p_registers.reg_esp;	
	size_t src_size = src_stack_top - src_stack_bottom;
	
	uint32_t dest_stack_top = PROC1_STACK_ADDR + (dest_pid)*PROC_STACK_SIZE;
	uint32_t dest_stack_bottom = dest_stack_top - src_size;
	
	// copy stacks and set dest's reg_esp
	memcpy((void *)dest_stack_top, (const void*) src_stack_top, src_size);	
	dest->p_registers.reg_esp = dest_stack_bottom;
	
	return;
}
