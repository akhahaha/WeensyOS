-------------------------------------------------------------------------------
UCLA CS 111 Minilab 1. "WeensyOS"
Professor Peter Reiher
Winter 2014

FILE:	answers.txt

AUTHOR(s):
Alan Kha        904030522	akhahaha@gmail.com

-------------------------------------------------------------------------------

EXERCISE 1:
No. Scheduling another process may overwrite the eax register, which is 
required to return the correct pid value.

EXERCISE 2:
// mpos-kern.c line 236
static pid_t o_fork(process_t *parent)
{	
	pid_t pid = 1;
	process_t* proc;
	do
	{
		proc = &proc_array[pid];
		
		if (proc->p_state == P_EMPTY)
		{
			proc->p_registers = parent->p_registers;
			copy_stack(proc, parent);
			proc->p_state = P_RUNNABLE;
			proc->p_registers.reg_eax = 0; // returns 0 to child
			return pid;
		}
		
		pid++;
	} while (pid < NPROCS);

	return -1;
}

// mpos-kern.c line 278
static void copy_stack(process_t *dest, process_t *src)
{	
	// get pids for source and destination
	pid_t src_pid = src->p_pid;
	pid_t dest_pid = dest->p_pid;
	
	uint32_t src_stack_top = PROC1_STACK_ADDR + (src_pid)*PROC_STACK_SIZE;
	uint32_t src_stack_bottom = src->p_registers.reg_esp;	
	size_t src_size = src_stack_top - src_stack_bottom;
	
	uint32_t dest_stack_top = PROC1_STACK_ADDR + (dest_pid)*PROC_STACK_SIZE;
	uint32_t dest_stack_bottom = dest_stack_top - src_size;
	
	// copy stacks and set dest's reg_esp
	memcpy((void *)dest_stack_top, (const void*) src_stack_top, src_size);	
	dest->p_registers.reg_esp = dest_stack_bottom;
	
	return;
}

EXERCISE 3:
Setting a process's state to BLOCKED essentially puts it to sleep, since 
schedule() only runs processes in the RUNNABLE state. After a process exits, 
the waiting processes can be awakened by setting its state back to RUNNABLE, 
and passing the returned value to the waiting process's eax register.

// mpos-kern.c, interrupt() line 164
case INT_SYS_EXIT:
	current->p_state = P_ZOMBIE;
	current->p_exit_status = current->p_registers.reg_eax;
	
	if (current->p_waiting != NULL)	// wake any sleeping processes
	{
		current->p_waiting->p_state = P_RUNNABLE;
		current->p_waiting->p_registers.reg_eax = current->p_exit_status;
	}
	
	schedule();
	
// mpos-kern.c, interrupt() line 183
case INT_SYS_WAIT: {
	pid_t p = current->p_registers.reg_eax;
	if (p <= 0 || p >= NPROCS || p == current->p_pid
		|| proc_array[p].p_state == P_EMPTY)
		current->p_registers.reg_eax = -1;
	else if (proc_array[p].p_state == P_ZOMBIE)
		current->p_registers.reg_eax = proc_array[p].p_exit_status;
	else
	{
		proc_array[p].p_waiting = current;	// add calling process to wait queue
		current->p_state = P_BLOCKED;		// put calling process to sleep
	}
	schedule();
	
EXERCISE 4:
Set state of any processes that returned successfully to a waiting process to 
EMPTY, freeing them for reuse.

// mpos-kern.c, interrupt() line 178
// mpos-kern.c, interrupt() line 200

EXERCISE 5:
void start(void)
{
	int x = 0;  /* note that local variable x lives on the stack */

 	volatile int *i = &x;	// pointer to volatile integer
	int *volatile j = &x;	// volatile pointer pointer to non-volatile integer

	pid_t p = sys_fork();
	if (p == 0) // if child process
	{
		i = &x; j = &x;
		*i = 1;	*j = 1;
	}
	else if (p > 0)
		sys_wait(p); // assume blocking implementation
	app_printf("%d", x);
	sys_exit(0);
}
